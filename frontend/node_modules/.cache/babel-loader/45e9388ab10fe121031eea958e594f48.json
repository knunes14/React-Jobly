{"ast":null,"code":"import _classCallCheck from \"/Users/keegannunes/Documents/react-jobly/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/keegannunes/Documents/react-jobly/frontend/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/keegannunes/Documents/react-jobly/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/keegannunes/Documents/react-jobly/frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"/Users/keegannunes/Documents/react-jobly/frontend/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nexport var InvalidTokenError = /*#__PURE__*/function (_Error) {\n  _inherits(InvalidTokenError, _Error);\n  function InvalidTokenError() {\n    _classCallCheck(this, InvalidTokenError);\n    return _possibleConstructorReturn(this, _getPrototypeOf(InvalidTokenError).apply(this, arguments));\n  }\n  return InvalidTokenError;\n}(_wrapNativeSuper(Error));\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {\n    var code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = \"0\" + code;\n    }\n    return \"%\" + code;\n  }));\n}\nfunction base64UrlDecode(str) {\n  var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += \"==\";\n      break;\n    case 3:\n      output += \"=\";\n      break;\n    default:\n      throw new Error(\"base64 string is not of the correct length\");\n  }\n  try {\n    return b64DecodeUnicode(output);\n  } catch (err) {\n    return atob(output);\n  }\n}\nexport function jwtDecode(token, options) {\n  if (typeof token !== \"string\") {\n    throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n  }\n  options || (options = {});\n  var pos = options.header === true ? 0 : 1;\n  var part = token.split(\".\")[pos];\n  if (typeof part !== \"string\") {\n    throw new InvalidTokenError(\"Invalid token specified: missing part #\".concat(pos + 1));\n  }\n  var decoded;\n  try {\n    decoded = base64UrlDecode(part);\n  } catch (e) {\n    throw new InvalidTokenError(\"Invalid token specified: invalid base64 for part #\".concat(pos + 1, \" (\").concat(e.message, \")\"));\n  }\n  try {\n    return JSON.parse(decoded);\n  } catch (e) {\n    throw new InvalidTokenError(\"Invalid token specified: invalid json for part #\".concat(pos + 1, \" (\").concat(e.message, \")\"));\n  }\n}","map":null,"metadata":{},"sourceType":"module"}